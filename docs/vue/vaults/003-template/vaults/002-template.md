在 Vue 2 和 Vue 3 中，构建视图最常用的语法有两种：一种是模板（template），另一种是 JSX。其中最主要使用的是模板。

模板主要由两部分组成：一种是插值语法，另一种是指令。插值语法是使用 `{{ }}` 来包裹变量，而指令是通过 `v-` 开头的自定义属性。



## 插值语法

在插值语法（即小胡子语法）和指令的值中，嵌入的都是**合法的 JavaScript 表达式计算后的值**。这些表达式可以分为以下几种：

1. 变量、状态和属性
2. 数学运算
3. 三元运算
4. `map`、`filter`、`find` 等方法
5. 一些被加入到 Vue 白名单中的全局方法

> `{expression}` => React中使用 => 大胡子语法
>
> `{{ expression }}` => Vue中使用 => 插值语法( 小胡子语法 )



### 可以渲染的值

在Mustache语法中：

- `null` 和 `undefined` 会渲染为空。
- 普通对象和数组会调用 `JSON.stringify()` 进行渲染。
- 其他对象会通过 `toString()` 方法将其渲染为字符串。
  - 在 Vue 2 中，`Symbol` 不能直接作为插值语法的表达式值，而只能作为一个状态的值，然后通过 `Mustache` 进行渲染；在 Vue 3 中没有这个问题。
  - `String(10n) => 10`



### 实现细节:

`new Vue()` => `_init()` => `initState()`

1. 如果有props options，初始化props
2. 执行setup
3. 如果有methods options，初始化methods
4. 如果有data options，初始化data => 执行`initData`
5. 如果有computed options，初始化computed
6. 如果有watch options，初始化watch

所以对应状态只会在组件实例化时被数据劫持，后续再往data上添加的数据将不再具备响应式



#### initData中处理的事情

+ 把data中的数据挂载到实例上
+ 并且对data中的每一项数据进行数据劫持



**注意点:**

1. **在 Vue2 中，数据响应式是深度响应式。**

   + `data` option 对应的值应该是个对象，该对象会被响应式处理。

   + 如果该对象中的值有普通对象或数组，则依旧会被进行响应式处理。

   + 只会对普通对象和数组进行响应式处理，如果是一些别的对象，如函数或正则对象等，它们将不会被进行响应式处理。

     

2. 如果属性值是一个被冻结了的对象，则它不会被进行任何响应式处理，因为冻结对象没有办法进行数据劫持。

   + 假设`vm.frozenObj`是被冻结的，则`vm.frozenObj.x = 10`并不能触发响应式，但`vm.frozenObj = {x: 10}`会触发响应式

   

3. 对于对象而言，它会被进行 getter 和 setter 劫持。
   而对于数组而言，它并没有进行 getter 和 setter 劫持，而是重写了数组的原型链，

   在数值原型链和数组实例中插入了一个自定义原型，在该原型中重写了数组的 `pop`、`push`、`unshift`、`shift`、`reverse`、`splice` 和 `sort` 这七个方法。「 `数组.__proto__` => `自定义原型` => `Array.prototype` 」 => 「 `vm.arr.splice(0, 1)` 或者 `vm.arr = [...vm.arr, 10]`这种形式会触发响应式 」

   + 这就意味着直接通过索引去修改数组元素并不会触发响应式 「 `vm.arr[0] = 200` 是不会触发响应式的 」

   

4. Vue 内部进行响应式处理时，使用的是 `Object.keys` 方法。
   而 `Object.keys` 方法只能获取对象自身的可枚举（enumerable）非 Symbol 类型属性。
   这也就意味着，如果 `data` 中定义的数据是不可迭代的或是 Symbol 类型属性，那么它并不能被 Vue 获取，

   不仅不会被挂载到 Vue 的实例上，更不会进行任何响应式处理。





数据劫持的操作，发生在“new”这个阶段，此时在data中写的数据，才会被劫持；在“new”之后，手动设置的新对象成员，默认是不会被数据劫持的！！

所以建议：以后在项目开发中，所有需要的数据，先在data中进行声明并赋予初始值，最起码这样可以保证，这些数据先被劫持！！

如果就不想事先在data中写好，就想后面慢慢加，我们可以基于 `$set` `Vue.prototype` 这个方法进行处理！！「 vm.$set === Vue.set // => true 」



`vm.$set([object], [key], [value])`

+ 不能基于$set给vm实例对象设置属性 
  + 「 也就是不能给vm和`vm.$data`设置属性，毕竟`vm.$data`在被响应式处理后依旧会需要挂载到vm上 」

  + 或者在简单点来说，vue不能给data配置项的一级属性进行后绑定扩展，但是可以给data配置项的二级属性及更深层级属性进行后绑定扩展

+ 如果是新增二级或更深级别成员，则会将对应成员进行数据劫持后进行添加，并进行界面刷新以收集对应依赖

+ 如果是通过`$set`修改之前的非响应式数据，`$set`也无法将之前的非响应式数据修改为响应式状态